{
  "hash": "6709b469a24891a07258c6d14f350b19",
  "result": {
    "markdown": "---\ntitle: \"The Cantor Pairing Function\"\ndate: \"2020-04-25\"\ncategories: [hashing, set theory]\n---\n\nOne surprising fact from set theory is that integers and rational numbers have the same cardinality as natural numbers. This can be proved by a standard trick named diagonal progression invented by Cantor. The underlying function is the Cantor pairing function. Yesterday I was writing codes to hash two integers and using the Cantor pairing function turns out to be a neat way.\n\nFormally, the Cantor pairing function $\\pi$ is defined as:\n\n$$\n\\begin{gathered}\n\\pi:\\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N} \\\\\n\\pi(k_1, k_2) := \\frac{1}{2} (k_1 + k_2)(k_1 + k_2 + 1) + k2\n\\end{gathered}\n$$\n\nIt can also be easily extended to multiple dimensions cases:\n\n$$\n\\begin{gathered}\n\\pi^{(n)}:\\mathbb{N}^n \\to \\mathbb{N} \\\\\n\\pi^{(n)}(k_1, \\ldots, k_{n-1}, k_n) := \\pi ( \\pi^{(n-1)}(k_1, \\ldots, k_{n-1}) , k_n), \\quad n>2\n\\end{gathered}\n$$\n\nThe Cantor pairing function is bijective. To prove that, we just need to invert it ([details](https://en.wikipedia.org/wiki/Pairing_function#Inverting_the_Cantor_pairing_function]) can be found  in Wikepidia). \n\nSimple python and C++ implementations:\n\n::: {.panel-tabset}\n## Python\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef cantor_pairing(x, y):\n    return int((x + y) * (x + y + 1) / 2 + y)\n\n\ndef cantor_pairing_nd(*args):\n    if len(args) == 2:\n        return cantor_pairing(args[0], args[1])\n    return cantor_pairing(cantor_pairing_nd(*args[:-1]), args[-1])\n\n\ncantor_pairing_nd(1, 2, 3)\n```\n:::\n\n\n## C++\n```c++\nstruct pair_hash\n{\n\tstd::size_t operator() (const std::pair<int, int>& p) const\n\t{\n\t\treturn (p.first + p.second) * (p.first + p.second + 1) / 2 + p.second;\n\t}\n};\n\nunordered_map<pair<int, int>, int, pair_hash> um;\num[make_pair(1,2)] = 0;\n```\n:::\n\nTo see the connection between the diagonal progression and the Cantor pairing function, we can do a formal analysis or directly visualize its graphical shape. The arrow direction indicates the monotonic increase of the Cantor pairing function (by 1 each time): \n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport collections\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nd = {}\nfor i in range(1, 10):\n    for j in range(1, 10):\n        val = cantor_pairing(i, j)\n        d[val] = np.array((i, j))\nod = collections.OrderedDict(sorted(d.items()))\n\nplt.figure(facecolor=\"w\")\nplt.axis([0, 10, 0, 10])\nplt.axis(\"off\")\nfor k, v in od.items():\n    if v[0] == 9 and v[1] == 2:\n        break\n    plt.annotate(text=\"{}/{}\".format(*v), xy=v, ha=\"center\", va=\"center\")\n    if \"v0\" in locals():\n        plt.annotate(\n            text=\"\",\n            xy=v0 + (v - v0) * 0.2 / np.linalg.norm(v - v0),\n            xytext=v - (v - v0) * 0.2 / np.linalg.norm(v - v0),\n            arrowprops=dict(arrowstyle=\"<-\"),\n        )\n    v0 = v\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=540 height=382}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}